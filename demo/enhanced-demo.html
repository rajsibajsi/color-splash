<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Splash Library - Enhanced Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .feature-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .feature-card.active {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .feature-card h3 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .upload-area {
            border: 3px dashed #007bff;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            background: #e9ecef;
            border-color: #0056b3;
        }

        .upload-area.dragover {
            background: #e3f2fd;
            border-color: #2196f3;
            transform: scale(1.02);
        }

        #fileInput {
            display: none;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .canvas-wrapper {
            text-align: center;
        }

        .canvas-wrapper h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        canvas {
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
        }

        .controls-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }

        label {
            font-weight: 500;
            color: #495057;
            min-width: 100px;
            font-size: 0.9em;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
        }

        select, input[type="text"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 0.9em;
        }

        .value-display {
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            color: #007bff;
            font-size: 0.9em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .buttons {
            text-align: center;
            margin: 20px 0;
            gap: 15px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .selection-area {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .info-panel {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            border-left: 4px solid #dc3545;
            display: none;
        }

        .error.active {
            display: block;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .format-support {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .format-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .format-supported {
            background: #d4edda;
            color: #155724;
        }

        .format-unsupported {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 768px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }

            .controls-section {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Color Splash Enhanced Demo</h1>
        <p class="subtitle">Showcasing File I/O, GPU Acceleration, and Selection Areas</p>

        <div class="features-grid">
            <div class="feature-card" id="fileIOCard">
                <h3>üìÅ File I/O Backend</h3>
                <p>Direct file loading and saving with format detection</p>
                <div class="format-support" id="formatSupport"></div>
            </div>
            <div class="feature-card" id="gpuCard">
                <h3>‚ö° GPU Acceleration</h3>
                <p>WebGL-powered hardware acceleration</p>
                <div id="gpuStatus">Status: Not initialized</div>
            </div>
            <div class="feature-card" id="selectionCard">
                <h3>üéØ Selection Areas</h3>
                <p>Apply effects to specific regions with feathering</p>
                <div id="selectionStatus">Click and drag to create selection</div>
            </div>
        </div>

        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <h3>üìÅ Upload Image</h3>
            <p>Click here or drag & drop an image file</p>
            <p><small>Supports JPG, PNG, WebP formats with auto-detection</small></p>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing image...</p>
        </div>

        <div class="error" id="error"></div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h4>Original Image</h4>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h4>Color Splash Result</h4>
                <canvas id="resultCanvas"></canvas>
            </div>
        </div>

        <div class="controls-section">
            <div class="control-group">
                <h3>üéØ Color Selection</h3>
                <div class="control-row">
                    <label>Method:</label>
                    <select id="colorSelectMethod">
                        <option value="click">Click Color (auto-apply)</option>
                        <option value="area">Selection Area (click color, drag area, then apply)</option>
                    </select>
                </div>
                <div id="colorInfo" style="display: none;">
                    <div class="control-row">
                        <div id="colorPreview" style="width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 4px;"></div>
                        <span id="colorDetails">No color selected</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>‚öôÔ∏è Processing Options</h3>
                <div class="control-row">
                    <label>GPU Acceleration:</label>
                    <button id="toggleGPU" onclick="toggleGPU()">Enable GPU</button>
                </div>
                <div class="control-row">
                    <label>Color Space:</label>
                    <select id="colorSpace">
                        <option value="hsv" selected>HSV</option>
                        <option value="lab">LAB</option>
                        <option value="rgb">RGB</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Preview Quality:</label>
                    <select id="previewQuality">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high" selected>High</option>
                        <option value="realtime">Realtime</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <h3>üé® Color Tolerance</h3>
                <div class="control-row">
                    <label>Hue:</label>
                    <input type="range" id="hueRange" min="0" max="60" value="20">
                    <span class="value-display" id="hueValue">20</span>
                </div>
                <div class="control-row">
                    <label>Saturation:</label>
                    <input type="range" id="satRange" min="0" max="100" value="30">
                    <span class="value-display" id="satValue">30</span>
                </div>
                <div class="control-row">
                    <label>Lightness:</label>
                    <input type="range" id="lightRange" min="0" max="100" value="25">
                    <span class="value-display" id="lightValue">25</span>
                </div>
            </div>

            <div class="control-group">
                <h3>üìÑ File I/O</h3>
                <div class="control-row">
                    <label>Save Format:</label>
                    <select id="saveFormat">
                        <option value="png">PNG</option>
                        <option value="jpeg">JPEG</option>
                        <option value="webp">WebP</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Quality:</label>
                    <input type="range" id="qualityRange" min="0.1" max="1" step="0.1" value="0.9">
                    <span class="value-display" id="qualityValue">0.9</span>
                </div>
                <div class="control-row">
                    <label>Filename:</label>
                    <input type="text" id="filename" value="color-splash-result" placeholder="filename">
                </div>
            </div>
        </div>

        <div class="selection-area" id="selectionArea" style="display: none;">
            <h4>üéØ Selection Area Controls</h4>
            <div class="control-row">
                <label>Feather:</label>
                <input type="range" id="featherRange" min="0" max="50" value="10">
                <span class="value-display" id="featherValue">10</span>
            </div>
            <div class="control-row">
                <button onclick="clearSelection()">Clear Selection</button>
                <button onclick="applyToSelection()">Apply to Selection</button>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="loadTime">-</div>
                <div class="stat-label">Load Time (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="processTime">-</div>
                <div class="stat-label">Process Time (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="imageSize">-</div>
                <div class="stat-label">Image Size</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="gpuStatus2">CPU</div>
                <div class="stat-label">Processing Mode</div>
            </div>
        </div>

        <div class="buttons">
            <button id="applyEffect" disabled>üé® Apply Effect</button>
            <button id="downloadResult" class="btn-success" disabled>üíæ Download Result</button>
            <button id="resetImage" disabled>üîÑ Reset</button>
            <button onclick="showPerformanceStats()" class="btn-warning">üìä Performance Stats</button>
        </div>

        <div class="info-panel" id="performanceInfo" style="display: none;">
            <h4>üìä Performance Information</h4>
            <div id="perfDetails"></div>
        </div>
    </div>

    <!-- Load the Color Splash library -->
    <script src="../dist/index.js"></script>

    <script>
        // Initialize variables
        let colorSplash;
        let originalImageData;
        let currentImageData;
        let selectedColor = null;
        let selectionArea = null;
        let isSelecting = false;
        let selectionStart = null;

        // Canvas references
        let originalCanvas, resultCanvas;
        let originalCtx, resultCtx;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeDemo();
        });

        async function initializeDemo() {
            try {
                // Initialize canvases
                originalCanvas = document.getElementById('originalCanvas');
                resultCanvas = document.getElementById('resultCanvas');
                originalCtx = originalCanvas.getContext('2d');
                resultCtx = resultCanvas.getContext('2d');

                // Initialize ColorSplash with enhanced options
                colorSplash = new ColorSplash.ColorSplash({
                    previewQuality: ColorSplash.PreviewQuality.HIGH,
                    defaultColorSpace: ColorSplash.ColorSpace.HSV,
                    maxPreviewSize: 800,
                    gpuAcceleration: false
                });

                // Setup event listeners
                setupEventListeners();

                // Check format support
                updateFormatSupport();

                console.log('Enhanced Color Splash Demo initialized!');

            } catch (error) {
                showError('Failed to initialize demo: ' + error.message);
                console.error('Initialization error:', error);
            }
        }

        function setupEventListeners() {
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);

            // Drag and drop
            const uploadArea = document.querySelector('.upload-area');
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            // Canvas interactions
            originalCanvas.addEventListener('click', handleCanvasClick);
            originalCanvas.addEventListener('mousedown', handleMouseDown);
            originalCanvas.addEventListener('mousemove', handleMouseMove);
            originalCanvas.addEventListener('mouseup', handleMouseUp);

            // Control listeners
            document.getElementById('hueRange').addEventListener('input', updateControlValues);
            document.getElementById('satRange').addEventListener('input', updateControlValues);
            document.getElementById('lightRange').addEventListener('input', updateControlValues);
            document.getElementById('qualityRange').addEventListener('input', updateControlValues);
            document.getElementById('featherRange').addEventListener('input', updateControlValues);

            // Button listeners
            document.getElementById('applyEffect').addEventListener('click', applyColorSplash);
            document.getElementById('downloadResult').addEventListener('click', downloadResult);
            document.getElementById('resetImage').addEventListener('click', resetImage);

            // Selection method change
            document.getElementById('colorSelectMethod').addEventListener('change', handleSelectionMethodChange);
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                await loadImageFile(file);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        async function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                await loadImageFile(files[0]);
            }
        }

        async function loadImageFile(file) {
            showLoading(true, 'Loading image with File I/O Backend...');

            try {
                const startTime = performance.now();

                // Use the new File I/O backend to load the image directly
                originalImageData = await colorSplash.loadFromFile(file, {
                    maxWidth: 1200,
                    maxHeight: 1200
                });

                const loadTime = performance.now() - startTime;
                document.getElementById('loadTime').textContent = loadTime.toFixed(1);

                // Setup canvases
                const maxDisplaySize = 600;
                let displayWidth = originalImageData.width;
                let displayHeight = originalImageData.height;

                if (originalImageData.width > maxDisplaySize || originalImageData.height > maxDisplaySize) {
                    const ratio = Math.min(maxDisplaySize / originalImageData.width, maxDisplaySize / originalImageData.height);
                    displayWidth = originalImageData.width * ratio;
                    displayHeight = originalImageData.height * ratio;
                }

                // Setup original canvas
                originalCanvas.width = originalImageData.width;
                originalCanvas.height = originalImageData.height;
                originalCanvas.style.width = displayWidth + 'px';
                originalCanvas.style.height = displayHeight + 'px';
                originalCtx.putImageData(originalImageData, 0, 0);

                // Setup result canvas
                resultCanvas.width = originalImageData.width;
                resultCanvas.height = originalImageData.height;
                resultCanvas.style.width = displayWidth + 'px';
                resultCanvas.style.height = displayHeight + 'px';
                resultCtx.putImageData(originalImageData, 0, 0);

                currentImageData = originalImageData;

                // Update stats
                document.getElementById('imageSize').textContent =
                    `${originalImageData.width}x${originalImageData.height}`;

                // Preload for performance
                await colorSplash.preloadImage(originalImageData);

                // Enable controls
                enableControls(true);

                // Mark File I/O feature as active
                document.getElementById('fileIOCard').classList.add('active');

                showLoading(false);
                console.log(`Image loaded: ${originalImageData.width}x${originalImageData.height}`);

            } catch (error) {
                showError('Failed to load image: ' + error.message);
                showLoading(false);
                console.error('Load error:', error);
            }
        }

        async function handleCanvasClick(event) {
            if (!originalImageData) return;

            const method = document.getElementById('colorSelectMethod').value;

            // In area mode, only allow color selection if we're not currently selecting an area
            if (method === 'click' || (method === 'area' && !isSelecting)) {
                const rect = originalCanvas.getBoundingClientRect();
                const scaleX = originalCanvas.width / rect.width;
                const scaleY = originalCanvas.height / rect.height;

                const x = Math.floor((event.clientX - rect.left) * scaleX);
                const y = Math.floor((event.clientY - rect.top) * scaleY);

                // Select color at clicked position
                const newColor = colorSplash.selectColor(originalImageData, x, y);

                // In area mode, only update selectedColor if we don't have one yet, or if user explicitly clicks (not drags)
                if (method === 'click' || !selectedColor) {
                    selectedColor = newColor;
                    updateColorInfo(selectedColor);
                }

                // Only auto-apply in click mode
                if (method === 'click') {
                    await applyColorSplash();
                }
            }
        }

        function handleMouseDown(event) {
            const method = document.getElementById('colorSelectMethod').value;

            if (method === 'area') {
                isSelecting = true;
                const rect = originalCanvas.getBoundingClientRect();
                const scaleX = originalCanvas.width / rect.width;
                const scaleY = originalCanvas.height / rect.height;

                selectionStart = {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            }
        }

        function handleMouseMove(event) {
            if (!isSelecting || !selectionStart) return;

            const rect = originalCanvas.getBoundingClientRect();
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;

            const currentX = (event.clientX - rect.left) * scaleX;
            const currentY = (event.clientY - rect.top) * scaleY;

            // Draw selection rectangle (visual feedback)
            drawSelectionRectangle(selectionStart.x, selectionStart.y, currentX, currentY);
        }

        function handleMouseUp(event) {
            if (!isSelecting || !selectionStart) return;

            const rect = originalCanvas.getBoundingClientRect();
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;

            const endX = (event.clientX - rect.left) * scaleX;
            const endY = (event.clientY - rect.top) * scaleY;

            // Create selection area with proper coordinate format
            const rectX = Math.min(selectionStart.x, endX);
            const rectY = Math.min(selectionStart.y, endY);
            const rectWidth = Math.abs(endX - selectionStart.x);
            const rectHeight = Math.abs(endY - selectionStart.y);

            selectionArea = {
                type: 'rectangle',
                coordinates: [
                    { x: rectX, y: rectY },                           // Top-left
                    { x: rectX + rectWidth, y: rectY + rectHeight }   // Bottom-right
                ],
                featherRadius: parseInt(document.getElementById('featherRange').value),
                // Keep the original properties for display purposes
                _bounds: { x: rectX, y: rectY, width: rectWidth, height: rectHeight }
            };

            // Show selection controls
            document.getElementById('selectionArea').style.display = 'block';
            document.getElementById('selectionCard').classList.add('active');
            document.getElementById('selectionStatus').textContent =
                `Selection: ${Math.round(selectionArea._bounds.width)}x${Math.round(selectionArea._bounds.height)}`;

            isSelecting = false;
            selectionStart = null;
        }

        function drawSelectionRectangle(x1, y1, x2, y2) {
            // Clear and redraw original image
            originalCtx.putImageData(originalImageData, 0, 0);

            // Draw selection rectangle
            originalCtx.strokeStyle = '#007bff';
            originalCtx.lineWidth = 2;
            originalCtx.setLineDash([5, 5]);
            originalCtx.strokeRect(
                Math.min(x1, x2),
                Math.min(y1, y2),
                Math.abs(x2 - x1),
                Math.abs(y2 - y1)
            );
            originalCtx.setLineDash([]);
        }

        async function toggleGPU() {
            try {
                if (!colorSplash.getOptions().gpuAcceleration) {
                    // Add WebGL diagnostics
                    const webglSupported = checkWebGLSupport();
                    console.log('WebGL support check:', webglSupported);

                    if (!webglSupported.webgl1 && !webglSupported.webgl2) {
                        throw new Error('WebGL is not supported in this browser');
                    }

                    // Create a separate canvas for WebGL (can't share with 2D context)
                    const webglCanvas = document.createElement('canvas');
                    webglCanvas.width = resultCanvas.width;
                    webglCanvas.height = resultCanvas.height;

                    const success = await colorSplash.enableGPUAcceleration(webglCanvas);
                    if (success) {
                        document.getElementById('gpuStatus').textContent = 'Status: Enabled';
                        document.getElementById('gpuStatus2').textContent = 'GPU';
                        document.getElementById('toggleGPU').textContent = 'Disable GPU';
                        document.getElementById('gpuCard').classList.add('active');
                        console.log('GPU acceleration enabled with separate WebGL canvas');
                    } else {
                        // Get more detailed error information
                        const diagnostics = getWebGLDiagnostics(webglCanvas);
                        console.log('WebGL diagnostics:', diagnostics);
                        throw new Error(`Failed to initialize GPU acceleration. ${diagnostics.error || 'Check console for details'}`);
                    }
                } else {
                    colorSplash.disableGPUAcceleration();
                    document.getElementById('gpuStatus').textContent = 'Status: Disabled';
                    document.getElementById('gpuStatus2').textContent = 'CPU';
                    document.getElementById('toggleGPU').textContent = 'Enable GPU';
                    document.getElementById('gpuCard').classList.remove('active');
                    console.log('GPU acceleration disabled');
                }
            } catch (error) {
                showError('GPU toggle error: ' + error.message);
                console.error('GPU error:', error);
            }
        }

        function checkWebGLSupport() {
            const canvas = document.createElement('canvas');
            const webgl1 = canvas.getContext('webgl') !== null;
            const webgl2 = canvas.getContext('webgl2') !== null;

            return {
                webgl1,
                webgl2,
                supported: webgl1 || webgl2
            };
        }

        function getWebGLDiagnostics(canvas) {
            try {
                // Use the same context attributes as the backend
                const contextAttributes = {
                    alpha: true,
                    depth: false,
                    stencil: false,
                    antialias: false,
                    premultipliedAlpha: true,
                    preserveDrawingBuffer: false,
                    powerPreference: 'default',
                    failIfMajorPerformanceCaveat: false
                };

                const gl = canvas.getContext('webgl2', contextAttributes) ||
                          canvas.getContext('webgl', contextAttributes) ||
                          canvas.getContext('experimental-webgl', contextAttributes);

                if (!gl) {
                    return { error: 'Failed to get WebGL context with all fallbacks' };
                }

                const info = {
                    vendor: gl.getParameter(gl.VENDOR),
                    renderer: gl.getParameter(gl.RENDERER),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS)
                };

                // Test shader compilation
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);

                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    info.shaderError = gl.getShaderInfoLog(vertexShader);
                }

                gl.deleteShader(vertexShader);
                return info;

            } catch (error) {
                return { error: error.message };
            }
        }

        async function applyColorSplash() {
            if (!originalImageData) return;

            const method = document.getElementById('colorSelectMethod').value;

            if (method === 'click' && !selectedColor) {
                showError('Please select a color by clicking on the image');
                return;
            }

            if (method === 'area' && !selectionArea) {
                showError('Please create a selection area by dragging on the image');
                return;
            }


            showLoading(true, 'Applying color splash effect...');

            try {
                const startTime = performance.now();

                const tolerance = {
                    hue: parseInt(document.getElementById('hueRange').value),
                    saturation: parseInt(document.getElementById('satRange').value),
                    lightness: parseInt(document.getElementById('lightRange').value)
                };

                const colorSpace = document.getElementById('colorSpace').value;
                const previewQuality = document.getElementById('previewQuality').value;

                // Update settings
                colorSplash.setDefaultColorSpace(colorSpace);

                let result;

                if (method === 'click') {
                    // Standard color splash
                    result = await colorSplash.applyColorSplash(originalImageData, {
                        targetColors: [selectedColor],
                        tolerance: tolerance,
                        colorSpace: colorSpace,
                        grayscaleMethod: ColorSplash.GrayscaleMethod.LUMINANCE
                    });
                } else {
                    // Selection area color splash - use manually selected color if available
                    let targetColors;

                    if (selectedColor) {
                        // Use manually selected color
                        targetColors = [selectedColor];
                    } else {
                        // Fallback to average color in selection if no color was manually selected
                        const avgColor = getAverageColorInSelection(originalImageData, selectionArea);
                        targetColors = [avgColor];
                    }

                    result = await colorSplash.applyColorSplashInSelection(
                        originalImageData,
                        selectionArea,
                        {
                            targetColors: targetColors,
                            tolerance: tolerance,
                            colorSpace: colorSpace,
                            grayscaleMethod: ColorSplash.GrayscaleMethod.LUMINANCE
                        }
                    );
                }

                // Display result
                resultCtx.putImageData(result, 0, 0);
                currentImageData = result;

                const processTime = performance.now() - startTime;
                document.getElementById('processTime').textContent = processTime.toFixed(1);

                showLoading(false);

            } catch (error) {
                showError('Error applying effect: ' + error.message);
                showLoading(false);
                console.error('Effect error:', error);
            }
        }

        function getAverageColorInSelection(imageData, area) {
            let totalR = 0, totalG = 0, totalB = 0, count = 0;

            // Use bounds for rectangular selections
            const bounds = area._bounds || {
                x: Math.min(...area.coordinates.map(p => p.x)),
                y: Math.min(...area.coordinates.map(p => p.y)),
                width: Math.max(...area.coordinates.map(p => p.x)) - Math.min(...area.coordinates.map(p => p.x)),
                height: Math.max(...area.coordinates.map(p => p.y)) - Math.min(...area.coordinates.map(p => p.y))
            };

            for (let y = bounds.y; y < bounds.y + bounds.height; y++) {
                for (let x = bounds.x; x < bounds.x + bounds.width; x++) {
                    if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
                        // Check if point is actually inside the selection area
                        if (colorSplash.isPointInArea(x, y, area)) {
                            const index = (y * imageData.width + x) * 4;
                            totalR += imageData.data[index];
                            totalG += imageData.data[index + 1];
                            totalB += imageData.data[index + 2];
                            count++;
                        }
                    }
                }
            }

            if (count === 0) {
                // Fallback to center pixel if no pixels found
                const centerX = Math.floor(bounds.x + bounds.width / 2);
                const centerY = Math.floor(bounds.y + bounds.height / 2);
                const index = (centerY * imageData.width + centerX) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2]
                };
            }

            return {
                r: Math.round(totalR / count),
                g: Math.round(totalG / count),
                b: Math.round(totalB / count)
            };
        }

        async function downloadResult() {
            if (!currentImageData) return;

            try {
                const format = document.getElementById('saveFormat').value;
                const quality = parseFloat(document.getElementById('qualityRange').value);
                const filename = document.getElementById('filename').value || 'color-splash-result';

                // Use the File I/O backend to download
                await colorSplash.downloadImage(currentImageData, {
                    format: format,
                    quality: quality,
                    filename: `${filename}.${format}`
                });

                console.log(`Image downloaded as ${filename}.${format}`);

            } catch (error) {
                showError('Download error: ' + error.message);
                console.error('Download error:', error);
            }
        }

        function clearSelection() {
            selectionArea = null;
            isSelecting = false;
            selectionStart = null;

            // Redraw original image without selection
            originalCtx.putImageData(originalImageData, 0, 0);

            // Hide selection controls
            document.getElementById('selectionArea').style.display = 'none';
            document.getElementById('selectionCard').classList.remove('active');
            document.getElementById('selectionStatus').textContent = 'Click and drag to create selection';
        }

        function applyToSelection() {
            applyColorSplash();
        }

        function resetImage() {
            if (!originalImageData) return;

            originalCtx.putImageData(originalImageData, 0, 0);
            resultCtx.putImageData(originalImageData, 0, 0);
            currentImageData = originalImageData;

            // Clear selection
            clearSelection();

            // Reset stats
            document.getElementById('processTime').textContent = '-';
        }

        function updateColorInfo(color) {
            const colorPreview = document.getElementById('colorPreview');
            const colorDetails = document.getElementById('colorDetails');
            const colorInfo = document.getElementById('colorInfo');

            colorPreview.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
            colorDetails.textContent = `RGB(${color.r}, ${color.g}, ${color.b})`;
            colorInfo.style.display = 'block';
        }

        function updateControlValues() {
            document.getElementById('hueValue').textContent = document.getElementById('hueRange').value;
            document.getElementById('satValue').textContent = document.getElementById('satRange').value;
            document.getElementById('lightValue').textContent = document.getElementById('lightRange').value;
            document.getElementById('qualityValue').textContent = document.getElementById('qualityRange').value;
            document.getElementById('featherValue').textContent = document.getElementById('featherRange').value;
        }

        function updateFormatSupport() {
            const formats = colorSplash.getSupportedFormats();
            const supportDiv = document.getElementById('formatSupport');

            Object.entries(formats).forEach(([format, supported]) => {
                const badge = document.createElement('span');
                badge.className = `format-badge ${supported ? 'format-supported' : 'format-unsupported'}`;
                badge.textContent = format.toUpperCase();
                supportDiv.appendChild(badge);
            });
        }

        function handleSelectionMethodChange() {
            const method = document.getElementById('colorSelectMethod').value;

            if (method === 'area') {
                originalCanvas.style.cursor = 'crosshair';
            } else {
                originalCanvas.style.cursor = 'pointer';
                clearSelection();
            }
        }

        function showPerformanceStats() {
            const stats = colorSplash.getPerformanceStats();
            const cacheStats = colorSplash.getCacheStats();

            let html = `<strong>Cache:</strong> ${cacheStats.size}/${cacheStats.maxSize} entries<br>`;

            Object.entries(stats).forEach(([operation, stat]) => {
                if (stat) {
                    html += `<strong>${operation}:</strong> avg ${stat.average.toFixed(1)}ms (${stat.count} calls)<br>`;
                }
            });

            document.getElementById('perfDetails').innerHTML = html;
            document.getElementById('performanceInfo').style.display = 'block';
        }

        function enableControls(enabled) {
            document.getElementById('applyEffect').disabled = !enabled;
            document.getElementById('downloadResult').disabled = !enabled;
            document.getElementById('resetImage').disabled = !enabled;
        }

        function showLoading(show, message = 'Processing...') {
            const loading = document.getElementById('loading');
            if (show) {
                loading.querySelector('p').textContent = message;
                loading.classList.add('active');
            } else {
                loading.classList.remove('active');
            }
        }

        function showError(message) {
            const error = document.getElementById('error');
            error.textContent = message;
            error.classList.add('active');
            setTimeout(() => error.classList.remove('active'), 5000);
        }

        // Initialize control values
        updateControlValues();
    </script>
</body>
</html>